"""
Useful python tools
"""

import subprocess, re, sys, os
import string
import random

import qsub

VARS = None
WORKDIR = None
TOTAL_CMDS = 0


class SampleInfo:
    """
    a class hold sample information from the samplesheet.
    """

    def __init__(self, record):
        """
        :param record: dict of a record in samplesheet, key=column name, value=cell value
        :return: None
        """

        try:
            self.runid = record['Sequencer ID'] if 'Sequencer ID' in record else ''
            self.project = record['Run ID'] if 'Run ID' in record else record['Sample_Project']
            self.name = record['Name for Sequencer - autogenerated'] if 'Name for Sequencer - autogenerated' in record else record['Sample_Name']
            sample_type = record['Sample type'].lower() if 'Sample type' in record else record['Description'].lower()
            if 'tumor' in sample_type or 'tumour' in sample_type:
                self.type = 'tumor'
            elif 'blood' in sample_type or 'normal' in sample_type:
                self.type = 'normal'
            elif sample_type == '':
                self.type = ''
            else:
                sys.stderr.write("I can not understand sample type of '{}', please use tumor/normal.\n".format(
                    record['Sample type']))
                self.type = None
            self.pair = record['Pair ID'].strip() if 'Pair ID' in record and record['Pair ID'].strip() else None

        except KeyError as e:
            sys.stderr.write(
                "Can not find column {} in the sample sheet.\n".format(e))
            exit(1)

    def __str__(self):
        return "RUN ID: {}; Project: {}; Sample Name: {}; Type: {}.".format(self.runid, self.project, self.name,
                                                                            self.type)

    @staticmethod
    def read_sample_sheet(samplesheet, sequencer_id=None):
        sheet = []
        with open(samplesheet, 'r') as f:
            line = f.readline() # we are not going to use the first line anyways

            # read until reach [data] if it is the sample sheet
            if line[0] == '[':
                while not line.startswith('[Data]'):
                    if line == '':
                        raise Exception("EOF reached before data.")
                    line = f.readline()

            header = f.readline().strip().split(',')
            for line in f:
                line = line.strip()
                if line.split(',')[0].strip():  # not empty line
                    row = {col: value for col, value in zip(header, line.split(','))}
                    if sequencer_id:
                        row['Sequencer ID'] = sequencer_id
                    sheet.append(SampleInfo(row))

        return sheet


    @staticmethod
    def get_pairs(records):
        result = []
        pairs = {}
        for record in records:
            if record.pair is None:
                result.append((record,))
            else:
                if record.pair in pairs:
                    pairs[record.pair].append(record)
                else:
                    pairs[record.pair] = [record]

        for k, v in pairs.items():
            result.append(v)

        # for k, v in pairs.items():
        #     if len(v) > 2:
        #         sys.stderr.write(
        #             "ERROR: Pair ID '{}' has more than 2 samples, ignored.\n".format(k))
        #     elif len(v) == 1:
        #         sys.stderr.write(
        #             "WARNING: Pair ID '{}' has only 1 sample.\n".format(k))
        #         result.append((v[0],))
        #     else:  # tumor sample first
        #         if v[0].type == v[1].type:
        #             sys.stderr.write(
        #                 "ERROR: Pair ID '{}': the two samples have the same type, ignored.\n".format(k))
        #         else:
        #             if v[0].type == 'tumor':
        #                 result.append((v[0], v[1]))
        #             else:
        #                 result.append((v[1], v[0]))

        return result

    @staticmethod
    def get_samples(pair, type=''):
        result = []
        for i in pair:
            if i.type == type:
                result.append(i)

        return result


def read_vars(ini=None):
    """
    read system environment and put into global variable VARS
    :param ini: ini file
    :return: None, result will be in VARS
    """
    #module loaded
    out = subprocess.getoutput('module list').replace('\n', ' ') + ' '
    tools = re.compile('\d+\) (.+?)/(.+?)\s', re.MULTILINE).findall(out)
    global VARS
    VARS = {}
    for i in tools:
        #if i[0] == 'python': continue

        if i[0] in VARS:
            print("Error: multiple {} modules were loaded. I am confused.".format(i[0]), file=sys.stderr)
            exit(1)
        else:
            VARS[i[0]] = i[1]

    #shell variables
    for k,v in os.environ.items():
        VARS[k] = v

    #ini file
    if ini is not None:
        with open(ini) as f:
            for line in f:
                if '=' in line:
                    k, v = line.split('=')
                    k = k.strip()
                    v = v.strip()
                    if k in VARS:
                        print("WARNING: I am overwriting {} with {}".format(k, v))
                    VARS[k] = v


def check_var(var):
    if VARS is None: read_vars()

    if var not in VARS:
        print("Please set {}".format(var), file=sys.stderr)
        exit(1)
    else:
        return VARS[var]

def set_var(var, value):
    if VARS is None: read_vars()

    VARS['var'] = value


def check_vars(vars):
    """
    check if modules or environmental variables are set.
    :param vars: array of variables to check
    :return: exit if the variable is not set
    """
    modules = {}

    for i in vars:
        modules[i] = check_var(i)

    return modules

def get_var(var):
    if VARS is None: read_vars()

    try:
        return VARS[var]
    except KeyError:
        return None


def tmpdir(N=8):
    return 'tmp' + ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(N))

def getwd():
    global WORKDIR
    if not WORKDIR:
        WORKDIR = os.getcwd()

    return WORKDIR

def jobs_summary(waitlist=None, **other_qsub_options):

    cmd = ( 'echo COMMANDS SUBMITTED: $(wc -l cmds_submitted|cut -f1 -d" ")>jobs_complete.txt\n'
            'echo COMMANDS RETURNED: $(wc -l exit_status.txt|cut -f1 -d" ")>>jobs_complete.txt\n'
            'echo SUCCESS: $(grep -c "EXIT STATUS: 0" exit_status.txt)>>jobs_complete.txt\n'
            'echo FAIL: $(grep -cv "EXIT STATUS: 0" exit_status.txt)>>jobs_complete.txt\n'
            'echo MISSING: $(echo $(wc -l cmds_submitted |cut -f1 -d" ")-$(wc -l exit_status.txt |cut -f1 -d" ")|bc)>>jobs_complete.txt')

    qsub.qsub('jobs_summary', cmd, waitlist=waitlist, must_run=True, **other_qsub_options)


def init_cmds():
    global TOTAL_CMDS
    TOTAL_CMDS = 0


def cmds_more():
    global TOTAL_CMDS
    TOTAL_CMDS += 1

def cmds_count():
    return TOTAL_CMDS
